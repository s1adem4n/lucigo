// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: connections.sql

package db

import (
	"context"
	"database/sql"
)

const createConnection = `-- name: CreateConnection :one
INSERT INTO
  connections (
    id,
    user_id,
    provider,
    email,
    token,
    refresh_token
  )
VALUES
  (?, ?, ?, ?, ?, ?) RETURNING id, user_id, provider, email, token, refresh_token
`

type CreateConnectionParams struct {
	ID           string         `json:"id"`
	UserID       string         `json:"userId"`
	Provider     string         `json:"provider"`
	Email        string         `json:"email"`
	Token        string         `json:"token"`
	RefreshToken sql.NullString `json:"refreshToken"`
}

func (q *Queries) CreateConnection(ctx context.Context, arg CreateConnectionParams) (*Connection, error) {
	row := q.db.QueryRowContext(ctx, createConnection,
		arg.ID,
		arg.UserID,
		arg.Provider,
		arg.Email,
		arg.Token,
		arg.RefreshToken,
	)
	var i Connection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.Email,
		&i.Token,
		&i.RefreshToken,
	)
	return &i, err
}

const getConnectionByProviderAndEmail = `-- name: GetConnectionByProviderAndEmail :one
SELECT
  id, user_id, provider, email, token, refresh_token
FROM
  connections
WHERE
  provider = ? AND
  email = ?
`

type GetConnectionByProviderAndEmailParams struct {
	Provider string `json:"provider"`
	Email    string `json:"email"`
}

func (q *Queries) GetConnectionByProviderAndEmail(ctx context.Context, arg GetConnectionByProviderAndEmailParams) (*Connection, error) {
	row := q.db.QueryRowContext(ctx, getConnectionByProviderAndEmail, arg.Provider, arg.Email)
	var i Connection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.Email,
		&i.Token,
		&i.RefreshToken,
	)
	return &i, err
}
